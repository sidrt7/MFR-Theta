# -*- coding: utf-8 -*-
"""Phase portrait fr.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wuiQNTeVMK1G8zsjWJPPkig_5R88fJzo
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import quad
from scipy.integrate import odeint
import math

t = np.linspace(0, 10, 1000)  # integrate from 0 to 10 with 1000 steps

# Define the parameters
eta_0 = -0.2
delta = 0.2
k = -2
n = 2

# Define the initial phase variable
N = 10000  # number of neurons
theta = np.random.uniform(0, 2*np.pi, N)  # initial phase angles

# Calculate the synaptic input
P_n = lambda theta: (1 - np.cos(theta))**n
integral, _ = quad(P_n, 0, 2*np.pi)  # compute the integral of P_n from 0 to 2*pi
a_n = np.pi*2/integral
I_syn = k / N * np.sum(a_n * (1 - np.cos(theta))**n)

# Define heterogeneity
# Define the Lorentzian distribution function
def lorentzian(eta, eta_0, delta):
    return (1/np.pi)*(delta/((eta-eta_0)**2 + delta**2))

# Generate N random values of eta_j from the Lorentzian distribution

probs = lorentzian(np.linspace(0, 1, N), eta_0, delta)
probs /= np.sum(probs)  # normalize probabilities so they sum to 1
eta = np.random.choice(np.linspace(0, 1, N), N, p=probs)

# Calculate H(z, n)
# Calculate A_q and Q_jm

def delta2(i, j):
    return int(i == j)

def Q(j, m, n):
    numerator = ((-1)**(j-2*m)) * math.factorial(n)
    denominator = (2**j) * math.factorial(m) * math.factorial(n-j) * math.factorial(j-m)
    return numerator / denominator

def A(q, n):
    total = 0
    for j in range(n+1):
        for m in range(j+1):
            total += delta2(j-2*m, q) * Q(j, m, n)
    return total

# Define the rescaled synaptic current

def H(z_t, n):
    a_n = np.pi*2/integral
    A_0 = A(0, n)
    summands = []
    for q in range(1, n+1):
        z_conj = np.conj(z_t)
        summand = A(q, n) * ((z_t)**q + z_conj**q)
        summands.append(summand)
    H_z = a_n * (A_0 + sum(summands))
    return H_z

# H_z = H(z_t, n)
# print(H_z)

#Define the differential equations
def dxdy(x, y, eta_0, delta, k, n, H, t):
    dx = ((x-1) * y)-((((x+1)**2 - y**2)/2) * delta) - ((x+1) * y) * (eta_0 + k * H(x+1j*y,n))
    dy = (-((x-1)**2 - y**2)/2) - ((x+1)* y * delta) + (((x+1)**2 - y**2)/2) * (eta_0 + k * H(x+1j*y,n))
    return np.array([dx,dy])

# Create a grid of numbers on the unit circle
x, y = np.meshgrid(np.linspace(-1, 1, 21), np.linspace(-1, 1, 21))

# Evaluate the differential equations at each point in the grid
dx, dy = dxdy(x, y, eta_0, delta, k, n, H, t)

# Plot the vector field only inside the unit circle
mask = x**2 + y**2 <= 1
plt.quiver(x[mask], y[mask], dx[mask], dy[mask])

# Plot the nullclines where dx/dt = 0 and dy/dt = 0
plt.contour(x, y, dx, levels=[0], colors='r')
plt.contour(x, y, dy, levels=[0], colors='b')

# Find the point where the nullclines intersect
intersection_point = np.argwhere((np.isclose(dx, 0) & np.isclose(dy, 0)))

# Plot the unit circle
circle = plt.Circle((0, 0), 1, fill=False)
plt.gca().add_artist(circle)

# Set the axis limits and aspect ratio
plt.xlim([-1.1, 1.1])
plt.ylim([-1.1, 1.1])
plt.gca().set_aspect('equal')

# Define the initial conditions for x and y
x0 = 0.5
y0 = 0.5
x0y0 = np.array([x0, y0])

plt.show()

"""Trajectories"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import quad
import math

t = np.linspace(0, 100, 10000)  # integrate from 0 to 10 with 1000 steps

# Define the parameters
eta_0 = -0.2
delta = 0.2
k = -2
n = 2

# Define the initial phase variable
N = 10000  # number of neurons
theta = np.random.uniform(0, 2*np.pi, N)  # initial phase angles

# Calculate the synaptic input
P_n = lambda theta: (1 - np.cos(theta))**n
integral, _ = quad(P_n, 0, 2*np.pi)  # compute the integral of P_n from 0 to 2*pi
a_n = np.pi*2/integral
I_syn = k / N * np.sum(a_n * (1 - np.cos(theta))**n)

# Define heterogeneity
# Define the Lorentzian distribution function
def lorentzian(eta, eta_0, delta):
    return (1/np.pi)*(delta/((eta-eta_0)**2 + delta**2))

# Generate N random values of eta_j from the Lorentzian distribution

probs = lorentzian(np.linspace(0, 1, N), eta_0, delta)
probs /= np.sum(probs)  # normalize probabilities so they sum to 1
eta = np.random.choice(np.linspace(0, 1, N), N, p=probs)

# Calculate H(z, n)
# Calculate A_q and Q_jm

def delta2(i, j):
    return int(i == j)

def Q(j, m, n):
    numerator = ((-1)**(j-2*m)) * math.factorial(n)
    denominator = (2**j) * math.factorial(m) * math.factorial(n-j) * math.factorial(j-m)
    return numerator / denominator

def A(q, n):
    total = 0
    for j in range(n+1):
        for m in range(j+1):
            total += delta2(j-2*m, q) * Q(j, m, n)
    return total

# Define the rescaled synaptic current

def H(z, n):
    a_n = np.pi*2/integral
    A_0 = A(0, n)
    summands = []
    for q in range(1, n+1):
        z_conj = np.conj(z)
        summand = A(q, n) * ((z)**q + z_conj**q)
        summands.append(summand)
    H_z = a_n * (A_0 + sum(summands))
    return H_z

# Define the differential equations
def dxdy(x, y, eta_0, delta, k, n, H, t):
    dx = ((x-1) * y)-((((x+1)**2 - y**2)/2) * delta) - ((x+1) * y) * (eta_0 + k * H(x+1j*y,n))
    dy = (-((x-1)**2 - y**2)/2) - ((x+1)* y * delta) + (((x+1)**2 - y**2)/2) * (eta_0 + k * H(x+1j*y,n))
    return np.array([dx,dy])

# Create a grid of numbers on the unit circle
x, y = np.meshgrid(np.linspace(-1, 1, 21), np.linspace(-1, 1, 21))

# Evaluate the differential equations at each point in the grid
dx, dy = dxdy(x, y, eta_0, delta, k, n, H, t)

# Plot the vector field only inside the unit circle
mask = x**2 + y**2 <= 1
plt.quiver(x[mask], y[mask], dx[mask], dy[mask])

# Plot the nullclines where dx/dt = 0 and dy/dt = 0
plt.contour(x, y, dx, levels=[0], colors='r')
plt.contour(x, y, dy, levels=[0], colors='b')

# Plot the unit circle
circle = plt.Circle((0, 0), 1, fill=False)
plt.gca().add_artist(circle)

# Set the axis limits and aspect ratio
plt.xlim([-1.1, 1.1])
plt.ylim([-1.1, 1.1])
plt.gca().set_aspect('equal')

# Define the 4th order Runge-Kutta method
def rk4_step(f, t, x, h, eta_0, delta, k, n, H):
    k1 = f(x[0], x[1], eta_0, delta, k, n, H, t)
    k2 = f(x[0] + h/2*k1[0], x[1] + h/2*k1[1], eta_0, delta, k, n, H, t + h/2)
    k3 = f(x[0] + h/2*k2[0], x[1] + h/2*k2[1], eta_0, delta, k, n, H, t + h/2)
    k4 = f(x[0] + h*k3[0], x[1] + h*k3[1], eta_0, delta, k, n, H, t + h)
    return x + h*(1/6)*(k1 + 2*k2 + 2*k3 + k4)

# Set initial conditions
x0 = np.array([0, 0.5])

# Use the Runge-Kutta method to solve the differential equations for the initial conditions
x = [x0]
h = 0.001
for i in range(len(t)-1):
    x_i = x[i]
    x_i1 = rk4_step(dxdy, t[i], x_i, h, eta_0, delta, k, n, H)
    x.append(x_i1)

# Plot the sample trajectory
x = np.array(x)
plt.plot(x[:, 0], x[:, 1], color='green')

plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import quad
import math

t = np.linspace(0, 100, 10000)  # integrate from 0 to 10 with 1000 steps

# Define the parameters
eta_0 = 0.2
delta = 0.1
k = 2
n = 2

# Define the initial phase variable
N = 10000  # number of neurons
theta = np.random.uniform(0, 2*np.pi, N)  # initial phase angles

# Calculate the synaptic input
P_n = lambda theta: (1 - np.cos(theta))**n
integral, _ = quad(P_n, 0, 2*np.pi)  # compute the integral of P_n from 0 to 2*pi
a_n = np.pi*2/integral
I_syn = k / N * np.sum(a_n * (1 - np.cos(theta))**n)

# Define heterogeneity
# Define the Lorentzian distribution function
def lorentzian(eta, eta_0, delta):
    return (1/np.pi)*(delta/((eta-eta_0)**2 + delta**2))

# Generate N random values of eta_j from the Lorentzian distribution

probs = lorentzian(np.linspace(0, 1, N), eta_0, delta)
probs /= np.sum(probs)  # normalize probabilities so they sum to 1
eta = np.random.choice(np.linspace(0, 1, N), N, p=probs)

# Calculate H(z, n)
# Calculate A_q and Q_jm

def delta2(i, j):
    return int(i == j)

def Q(j, m, n):
    numerator = ((-1)**(j-2*m)) * math.factorial(n)
    denominator = (2**j) * math.factorial(m) * math.factorial(n-j) * math.factorial(j-m)
    return numerator / denominator

def A(q, n):
    total = 0
    for j in range(n+1):
        for m in range(j+1):
            total += delta2(j-2*m, q) * Q(j, m, n)
    return total

# Define the rescaled synaptic current

def H(z, n):
    a_n = np.pi*2/integral
    A_0 = A(0, n)
    summands = []
    for q in range(1, n+1):
        z_conj = np.conj(z)
        summand = A(q, n) * ((z)**q + z_conj**q)
        summands.append(summand)
    H_z = a_n * (A_0 + sum(summands))
    return H_z

# Define the differential equations
def dxdy(x, y, eta_0, delta, k, n, H, t):
    dx = ((x-1) * y)-((((x+1)**2 - y**2)/2) * delta) - ((x+1) * y) * (eta_0 + k * H(x+1j*y,n))
    dy = (-((x-1)**2 - y**2)/2) - ((x+1)* y * delta) + (((x+1)**2 - y**2)/2) * (eta_0 + k * H(x+1j*y,n))
    return np.array([dx,dy])

# Create a grid of numbers on the unit circle
x, y = np.meshgrid(np.linspace(-1, 1, 21), np.linspace(-1, 1, 21))

# Evaluate the differential equations at each point in the grid
dx, dy = dxdy(x, y, eta_0, delta, k, n, H, t)

# Plot the vector field only inside the unit circle
mask = x**2 + y**2 <= 1
plt.quiver(x[mask], y[mask], dx[mask], dy[mask])

# Plot the nullclines where dx/dt = 0 and dy/dt = 0
plt.contour(x, y, dx, levels=[0], colors='r')
plt.contour(x, y, dy, levels=[0], colors='b')

# Plot the unit circle
circle = plt.Circle((0, 0), 1, fill=False)
plt.gca().add_artist(circle)

# Set the axis limits and aspect ratio
plt.xlim([-1.1, 1.1])
plt.ylim([-1.1, 1.1])
plt.gca().set_aspect('equal')

# Define a function to solve the differential equation using RK4 method
def rk4_step(f, t, x, h, eta_0, delta, k, n, H):
    k1 = f(x[0], x[1], eta_0, delta, k, n, H, t)
    k2 = f(x[0] + h/2*k1[0], x[1] + h/2*k1[1], eta_0, delta, k, n, H, t + h/2)
    k3 = f(x[0] + h/2*k2[0], x[1] + h/2*k2[1], eta_0, delta, k, n, H, t + h/2)
    k4 = f(x[0] + h*k3[0], x[1] + h*k3[1], eta_0, delta, k, n, H, t + h)
    return x + h*(1/6)*(k1 + 2*k2 + 2*k3 + k4)

# Define the initial conditions
x0 = np.array([1, 0])

# Use the Runge-Kutta method to solve the differential equations for the initial conditions
x = [x0]
h = 0.01
for i in range(len(t)-1):
    x_i = x[i]
    x_i1 = rk4_step(dxdy, t[i], x_i, h, eta_0, delta, k, n, H)
    x.append(x_i1)

# Plot the sample trajectory
x = np.array(x)
plt.plot(x[:, 0], x[:, 1], color='green')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import quad
import math

t = np.linspace(0, 100, 10000)  # integrate from 0 to 10 with 1000 steps

# Define the parameters
eta_0 = 10.75
delta = 0.5
k = -9
n = 2

# Define the initial phase variable
N = 10000  # number of neurons
theta = np.random.uniform(0, 2*np.pi, N)  # initial phase angles

# Calculate the synaptic input
P_n = lambda theta: (1 - np.cos(theta))**n
integral, _ = quad(P_n, 0, 2*np.pi)  # compute the integral of P_n from 0 to 2*pi
a_n = np.pi*2/integral
I_syn = k / N * np.sum(a_n * (1 - np.cos(theta))**n)

# Define heterogeneity
# Define the Lorentzian distribution function
def lorentzian(eta, eta_0, delta):
    return (1/np.pi)*(delta/((eta-eta_0)**2 + delta**2))

# Generate N random values of eta_j from the Lorentzian distribution

probs = lorentzian(np.linspace(0, 1, N), eta_0, delta)
probs /= np.sum(probs)  # normalize probabilities so they sum to 1
eta = np.random.choice(np.linspace(0, 1, N), N, p=probs)

# Calculate H(z, n)
# Calculate A_q and Q_jm

def delta2(i, j):
    return int(i == j)

def Q(j, m, n):
    numerator = ((-1)**(j-2*m)) * math.factorial(n)
    denominator = (2**j) * math.factorial(m) * math.factorial(n-j) * math.factorial(j-m)
    return numerator / denominator

def A(q, n):
    total = 0
    for j in range(n+1):
        for m in range(j+1):
            total += delta2(j-2*m, q) * Q(j, m, n)
    return total

# Define the rescaled synaptic current

def H(z, n):
    a_n = np.pi*2/integral
    A_0 = A(0, n)
    summands = []
    for q in range(1, n+1):
        z_conj = np.conj(z)
        summand = A(q, n) * ((z)**q + z_conj**q)
        summands.append(summand)
    H_z = a_n * (A_0 + sum(summands))
    return H_z

# Define the differential equations
def dxdy(x, y, eta_0, delta, k, n, H, t):
    dx = ((x-1) * y)-((((x+1)**2 - y**2)/2) * delta) - ((x+1) * y) * (eta_0 + k * H(x+1j*y,n))
    dy = (-((x-1)**2 - y**2)/2) - ((x+1)* y * delta) + (((x+1)**2 - y**2)/2) * (eta_0 + k * H(x+1j*y,n))
    return np.array([dx,dy])

# Create a grid of numbers on the unit circle
x, y = np.meshgrid(np.linspace(-1, 1, 21), np.linspace(-1, 1, 21))

# Evaluate the differential equations at each point in the grid
dx, dy = dxdy(x, y, eta_0, delta, k, n, H, t)

# Plot the vector field only inside the unit circle
mask = x**2 + y**2 <= 1
plt.quiver(x[mask], y[mask], dx[mask], dy[mask])

# Plot the nullclines where dx/dt = 0 and dy/dt = 0
plt.contour(x, y, dx, levels=[0], colors='r')
plt.contour(x, y, dy, levels=[0], colors='b')

# Plot the unit circle
circle = plt.Circle((0, 0), 1, fill=False)
plt.gca().add_artist(circle)

# Set the axis limits and aspect ratio
plt.xlim([-1.1, 1.1])
plt.ylim([-1.1, 1.1])
plt.gca().set_aspect('equal')

# Define a function to solve the differential equation using RK4 method
def rk4_step(f, t, x, h, eta_0, delta, k, n, H):
    k1 = f(x[0], x[1], eta_0, delta, k, n, H, t)
    k2 = f(x[0] + h/2*k1[0], x[1] + h/2*k1[1], eta_0, delta, k, n, H, t + h/2)
    k3 = f(x[0] + h/2*k2[0], x[1] + h/2*k2[1], eta_0, delta, k, n, H, t + h/2)
    k4 = f(x[0] + h*k3[0], x[1] + h*k3[1], eta_0, delta, k, n, H, t + h)
    return x + h*(1/6)*(k1 + 2*k2 + 2*k3 + k4)

# Define the initial conditions
x0 = np.array([0.80, 0.50])

# Use the Runge-Kutta method to solve the differential equations for the initial conditions
x = [x0]
h = 0.01
for i in range(len(t)-1):
    x_i = x[i]
    x_i1 = rk4_step(dxdy, t[i], x_i, h, eta_0, delta, k, n, H)
    x.append(x_i1)

# Plot the sample trajectory
x = np.array(x)
plt.plot(x[:, 0], x[:, 1], color='green')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import quad
import math

t = np.linspace(0, 100, 10000)  # integrate from 0 to 10 with 1000 steps

# Define the parameters
eta_0 = -7
delta = 0.5
k = 9
n = 2

# Define the initial phase variable
N = 10000  # number of neurons
theta = np.random.uniform(0, 2*np.pi, N)  # initial phase angles

# Calculate the synaptic input
P_n = lambda theta: (1 - np.cos(theta))**n
integral, _ = quad(P_n, 0, 2*np.pi)  # compute the integral of P_n from 0 to 2*pi
a_n = np.pi*2/integral
I_syn = k / N * np.sum(a_n * (1 - np.cos(theta))**n)

# Define heterogeneity
# Define the Lorentzian distribution function
def lorentzian(eta, eta_0, delta):
    return (1/np.pi)*(delta/((eta-eta_0)**2 + delta**2))

# Generate N random values of eta_j from the Lorentzian distribution

probs = lorentzian(np.linspace(0, 1, N), eta_0, delta)
probs /= np.sum(probs)  # normalize probabilities so they sum to 1
eta = np.random.choice(np.linspace(0, 1, N), N, p=probs)

# Calculate H(z, n)
# Calculate A_q and Q_jm

def delta2(i, j):
    return int(i == j)

def Q(j, m, n):
    numerator = ((-1)**(j-2*m)) * math.factorial(n)
    denominator = (2**j) * math.factorial(m) * math.factorial(n-j) * math.factorial(j-m)
    return numerator / denominator

def A(q, n):
    total = 0
    for j in range(n+1):
        for m in range(j+1):
            total += delta2(j-2*m, q) * Q(j, m, n)
    return total

# Define the rescaled synaptic current

def H(z, n):
    a_n = np.pi*2/integral
    A_0 = A(0, n)
    summands = []
    for q in range(1, n+1):
        z_conj = np.conj(z)
        summand = A(q, n) * ((z)**q + z_conj**q)
        summands.append(summand)
    H_z = a_n * (A_0 + sum(summands))
    return H_z

# Define the differential equations
def dxdy(x, y, eta_0, delta, k, n, H, t):
    dx = ((x-1) * y)-((((x+1)**2 - y**2)/2) * delta) - ((x+1) * y) * (eta_0 + k * H(x+1j*y,n))
    dy = (-((x-1)**2 - y**2)/2) - ((x+1)* y * delta) + (((x+1)**2 - y**2)/2) * (eta_0 + k * H(x+1j*y,n))
    return np.array([dx,dy])

# Create a grid of numbers on the unit circle
x, y = np.meshgrid(np.linspace(-1, 1, 21), np.linspace(-1, 1, 21))

# Evaluate the differential equations at each point in the grid
dx, dy = dxdy(x, y, eta_0, delta, k, n, H, t)

# Plot the vector field only inside the unit circle
mask = x**2 + y**2 <= 1
plt.quiver(x[mask], y[mask], dx[mask], dy[mask])

# Plot the nullclines where dx/dt = 0 and dy/dt = 0
plt.contour(x, y, dx, levels=[0], colors='r')
plt.contour(x, y, dy, levels=[0], colors='b')

# Plot the unit circle
circle = plt.Circle((0, 0), 1, fill=False)
plt.gca().add_artist(circle)

# Set the axis limits and aspect ratio
plt.xlim([-1.1, 1.1])
plt.ylim([-1.1, 1.1])
plt.gca().set_aspect('equal')

# Define a function to solve the differential equation using RK4 method
def rk4_step(f, t, x, h, eta_0, delta, k, n, H):
    k1 = f(x[0], x[1], eta_0, delta, k, n, H, t)
    k2 = f(x[0] + h/2*k1[0], x[1] + h/2*k1[1], eta_0, delta, k, n, H, t + h/2)
    k3 = f(x[0] + h/2*k2[0], x[1] + h/2*k2[1], eta_0, delta, k, n, H, t + h/2)
    k4 = f(x[0] + h*k3[0], x[1] + h*k3[1], eta_0, delta, k, n, H, t + h)
    return x + h*(1/6)*(k1 + 2*k2 + 2*k3 + k4)

# Define the initial conditions
x0 = np.array([0.75, 0.10])

# Use the Runge-Kutta method to solve the differential equations for the initial conditions
x = [x0]
h = 0.001
for i in range(len(t)-1):
    x_i = x[i]
    x_i1 = rk4_step(dxdy, t[i], x_i, h, eta_0, delta, k, n, H)
    x.append(x_i1)

# Plot the sample trajectory
x = np.array(x)
plt.plot(x[:, 0], x[:, 1], color='green')
plt.show()

